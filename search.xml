<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8特性之Lambda表达式]]></title>
    <url>%2F2019%2F07%2F21%2Fjava%2Fjava8%2Flambda%2F</url>
    <content type="text"><![CDATA[Lambda表达式 简介 Lambda是一个匿名函数，可以理解为一个可以传递的方法。可以使我们的代码更简洁，更灵活。 语法 示例 123456789//匿名内部类Runnable a = new Runnable()&#123; @Override public void run() &#123; System.out.println("lowe"); &#125;&#125;;//Lambda表达式Runnable b = () -&gt; System.out.println("lowe"); 左侧：指定参数 右侧：需要执行的方法体 语法1：无参 1Runnable b = () -&gt; System.out.println("lowe"); 语法2：1个参数 1Consumer&lt;String&gt; con = x -&gt; System.out.println(x); 语法3：2个参数 123 BiConsumer&lt;Integer, Integer&gt; bi = (x, y) -&gt; &#123; System.out.println(x + y);&#125;; 语法4：有返回值 123 Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; return Integer.compare(x, y);&#125;; 类型推断Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” 函数式接口 什么是函数式接口 只包含一个抽象方法的接口，称之为函数式接口。 并不是只能包含一个接口，java8中接口中可以定义默认方法 用default修饰 123456public interface Sized&#123; int size(); default boolean isEmpty()&#123; return size() == 0; &#125;&#125; 可以通过Lambda表达式创建该函数式接口 可以在函数式接口上使用注解 @FunctionalInterface，申明这是一个函数式接口 四大函数式接口 函数式接口 参数类型 返回类型 方法 Consumer&lt;T&gt; T void void accept(T t); Supplier&lt;T&gt; 无 T T get(); Function&lt;T, R&gt; T R R apply(T t); Predicate&lt;T&gt; T boolean boolean test(T t); Consumer&lt;T&gt; 消费型 12345678910 @Test public void test() &#123; testConsumer("lowe", s -&gt; System.out.println(s + " 工作")); testConsumer("lowe", s -&gt; System.out.println(s + " 休息")); &#125; public void testConsumer(String value, Consumer&lt;String&gt; consumer) &#123; consumer.accept(value); &#125;//lowe 工作//lowe 休息 Supplier 供给型 可以用来作为不接受参数的工厂方法 123Supplier&lt;Student&gt; supplier = () -&gt; new Student();Student student = supplier.get(); Student student2 = supplier.get(); Function&lt;T, R&gt; 函数型 123456789@Testpublic void test1() &#123; String result = testFunction("lowe", v -&gt; v + " 休息"); System.out.println(result);&#125;public String testFunction(String value, Function&lt;String, String&gt; function) &#123; return function.apply(value);&#125;//lowe 休息 Predicate 断言型 1234567891011121314151617@Testpublic void test2() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; list1 = testPredicate(list, value -&gt; value % 2 == 0); List&lt;Integer&gt; list2 = testPredicate(list, value -&gt; value % 2 == 1); //list1: 2,4 //list2: 1,3,5&#125;public List&lt;Integer&gt; testPredicate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pre) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (Integer integer : list) &#123; if (pre.test(integer)) &#123; result.add(integer); &#125; &#125; return result;&#125; 方法引用 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。 当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。 注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号”::”。 对象的实例方法 12345@Testpublic void test3() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); list.forEach(System.out::println);&#125; 类的静态方法 12345678@Testpublic void test3() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); list.forEach(Test1::print);&#125;public static void print(Integer integer) &#123; System.out.println(integer);&#125; 类的构造方法 12Function&lt;String, Student&gt; f = (s)-&gt; new Student(s);Function&lt;String, Student&gt; f1 = Student::new;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解java String(2)：String在JDK6、7、8中的变化]]></title>
    <url>%2F2019%2F07%2F15%2Fjava%2Fbasic%2Fstring2%2F</url>
    <content type="text"><![CDATA[内存划分差异 JDK6及之前：有永久代 ,常量池在方法区 JDK7：有永久代 但是逐步“去永久代”，常量池在堆 JDK8及之后：无永久代，常量池在堆 String.intern()方法分析 源码12345678910111213141516171819202122232425/** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &lt;code&gt;String&lt;/code&gt;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the * pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. * &lt;p&gt; * It follows that for any two strings &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, * &lt;code&gt;s.intern()&amp;nbsp;==&amp;nbsp;t.intern()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; * if and only if &lt;code&gt;s.equals(t)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in &amp;sect;3.10.5 of the * &lt;a href="http://java.sun.com/docs/books/jls/html/"&gt;Java Language * Specification&lt;/a&gt; * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */public native String intern(); 大概的意思是：当这个方法执行的时候，如果常量池中已经存在这个对象（通过equals方法判断），则返回这个对象的引用；否则创建这个对象添加到常量池中并返回对象的引用 共同点都是先去查看字符串常量池是否有该字符串，如果有，则返回字符串常量池中的引用。 不同点JDK6中是复制字符串至常量池JDK7、8中是不会将字符串复制到常量池，而只将该字符串的引用保存到常量池。 示例分析12345678910111213String s1 = new String("lowe");String s2 = s1.intern();String s3 = "lowe";System.out.println(s1==s2);System.out.println(s1==s3);System.out.println(s2==s3);String s4 = new String("hel") + new String("lo");String s5 = s4.intern();String s6 = "hello";System.out.println(s4==s5);System.out.println(s4==s6);System.out.println(s5==s6); JDK6中的执行结果： false false true false false true JDK7,8中的执行结果：false false true true true true 第一段代码 首先执行String s1 = new String(&quot;lowe&quot;);后，堆跟常量区中都会有对象生成，s1的结果是堆中的引用 String s2 = s1.intern();,由于常量区中已经存在对象，所以返回的是常量区的引用 String s3 = &quot;lowe&quot;;,返回的也是常量区的引用 第二段代码 JDK6 String s4 = new String(&quot;hel&quot;) + new String(&quot;lo&quot;);后，堆中有”hello”对象而常量区中没有，返回的结果是堆中的引用 String s5 = s4.intern();，由于常量区没有对象，所以将对象复制到常量区并返回常量区的引用 String s6 = &quot;hello&quot;;,返回的也是常量区的引用 JDK7,8 String s4 = new String(&quot;hel&quot;) + new String(&quot;lo&quot;);后，堆中有”hello”对象而常量区中没有，返回的结果是堆中的引用 String s5 = s4.intern();，由于常量区没有对象，将堆中的引用复制到常量池中，返回的结果就是堆中的引用 String s6 = &quot;hello&quot;;,返回的也是常量区的引用，也是堆中的引用]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解java String(1)]]></title>
    <url>%2F2019%2F07%2F09%2Fjava%2Fbasic%2Fstring1%2F</url>
    <content type="text"><![CDATA[前言 本文基于JDK8 String类1234567891011public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L;&#125; String类是final修饰的，即不可继承 String使用数组实现的 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; String对象一旦被创建就是固定不变的了 String中的操作都是生成新的String，原始的字符串并没有被改变 字符串常量池 字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。 字符串的创建 使用引号创建 String a = &quot;lowe&quot;; 使用引号来创建字符串，字符串都是常量，在编译期已经确定存储在常量池中了。 用引号创建一个字符串的时候，首先会去常量池中寻找有没有相等的这个常量对象，没有的话就在常量池中创建这个常量对象；有的话就直接返回这个常量对象的引用。 使用new关键字创建 String b = new String(&quot;lowe&quot;); 使用new的话，会在堆中分配内存 首先会去常量池中找有没有”lowe”，如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。 使用”+”拼接 常量拼接 String c = &quot;lo&quot; + &quot;we&quot;; 两个或者两个以上的字符串常量相加，在预编译的时候“+”会被优化，相当于把两个或者两个以上字符串常量自动合成一个字符串常量. 等同于String c = &quot;lowe&quot; 非常量拼接 String a = new String(“hel”) + new String(“lo”); 首先new String(&quot;hel&quot;)执行完成后，常量池跟堆中都会生成一个对象 同理new String(&quot;lo&quot;) JVM会自动创建StringBuilder进行优化，最终调用toString()方法，生成”hello”对象 最终堆中会有”hello”对象，而常量池中不会有 final优化 当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。 1234String a = "lowe";final String b = "lo";String c = b+ "we";//a==c 综合测试123String a = "lowe";String b = "lowe";System.out.println(a==b);//true 123String a=new String("lowe");String b=new String("lowe");System.out.println(a==b);//false 1234//编译期确定String a="lowe";String b="lo"+"we";System.out.println(a==b);//true 1234567//编译期无法确定String a="lowe";String b=new String("lowe");String c="lo" + new String("we");System.out.println(a==b);//falseSystem.out.println(a==c);//falseSystem.out.println(b==c);//false 123456//编译期无法确定String a = "lowe";String b = "lo";String c = "we";String d = b + c;System.out.println(a==d);//false 12345//final优化String a = "lowe";final String b = "lo";String c = b+ "we";System.out.println(a==c);//true 12345678910//虽然用final修饰了，但是是通过方法调用返回的，只能在运行期确定&#123; String a = "lowe"; final String b = getStr(); String c = b+ "we"; System.out.println(a==c);//false&#125;private static String getStr()&#123; return "lo";&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
