<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8特性之Lambda表达式]]></title>
    <url>%2F2019%2F07%2F21%2Fjava%2Fjava8%2Flambda%2F</url>
    <content type="text"><![CDATA[Lambda表达式 简介 Lambda是一个匿名函数，可以理解为一个可以传递的方法。可以使我们的代码更简洁，更灵活。 语法 示例 123456789//匿名内部类Runnable a = new Runnable()&#123; @Override public void run() &#123; System.out.println("lowe"); &#125;&#125;;//Lambda表达式Runnable b = () -&gt; System.out.println("lowe"); 左侧：指定参数 右侧：需要执行的方法体 语法1：无参 1Runnable b = () -&gt; System.out.println("lowe"); 语法2：1个参数 1Consumer&lt;String&gt; con = x -&gt; System.out.println(x); 语法3：2个参数 123 BiConsumer&lt;Integer, Integer&gt; bi = (x, y) -&gt; &#123; System.out.println(x + y);&#125;; 语法4：有返回值 123 Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; return Integer.compare(x, y);&#125;; 类型推断Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” 函数式接口 什么是函数式接口 只包含一个抽象方法的接口，称之为函数式接口。 并不是只能包含一个接口，java8中接口中可以定义默认方法 用default修饰 123456public interface Sized&#123; int size(); default boolean isEmpty()&#123; return size() == 0; &#125;&#125; 可以通过Lambda表达式创建该函数式接口 可以在函数式接口上使用注解 @FunctionalInterface，申明这是一个函数式接口 四大函数式接口 函数式接口 参数类型 返回类型 方法 Consumer&lt;T&gt; T void void accept(T t); Supplier&lt;T&gt; 无 T T get(); Function&lt;T, R&gt; T R R apply(T t); Predicate&lt;T&gt; T boolean boolean test(T t); Consumer&lt;T&gt; 消费型 12345678910 @Test public void test() &#123; testConsumer("lowe", s -&gt; System.out.println(s + " 工作")); testConsumer("lowe", s -&gt; System.out.println(s + " 休息")); &#125; public void testConsumer(String value, Consumer&lt;String&gt; consumer) &#123; consumer.accept(value); &#125;//lowe 工作//lowe 休息 Supplier 供给型 可以用来作为不接受参数的工厂方法 123Supplier&lt;Student&gt; supplier = () -&gt; new Student();Student student = supplier.get(); Student student2 = supplier.get(); Function&lt;T, R&gt; 函数型 123456789@Testpublic void test1() &#123; String result = testFunction("lowe", v -&gt; v + " 休息"); System.out.println(result);&#125;public String testFunction(String value, Function&lt;String, String&gt; function) &#123; return function.apply(value);&#125;//lowe 休息 Predicate 断言型 1234567891011121314151617@Testpublic void test2() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; list1 = testPredicate(list, value -&gt; value % 2 == 0); List&lt;Integer&gt; list2 = testPredicate(list, value -&gt; value % 2 == 1); //list1: 2,4 //list2: 1,3,5&#125;public List&lt;Integer&gt; testPredicate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pre) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (Integer integer : list) &#123; if (pre.test(integer)) &#123; result.add(integer); &#125; &#125; return result;&#125; 方法引用 方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。 当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。 注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号”::”。 对象的实例方法 12345@Testpublic void test3() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); list.forEach(System.out::println);&#125; 类的静态方法 12345678@Testpublic void test3() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); list.forEach(Test1::print);&#125;public static void print(Integer integer) &#123; System.out.println(integer);&#125; 类的构造方法 12Function&lt;String, Student&gt; f = (s)-&gt; new Student(s);Function&lt;String, Student&gt; f1 = Student::new;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解java String(1)]]></title>
    <url>%2F2019%2F07%2F09%2Fjava%2Fbasic%2Fstring1%2F</url>
    <content type="text"><![CDATA[String类1234567891011public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L;&#125; String类是final修饰的，即不可继承 String使用数组实现的 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; String对象一旦被创建就是固定不变的了 String中的操作都是生成新的String，原始的字符串并没有被改变 字符串常量池 字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。 字符串的创建1234//使用引号创建String a = "lowe";//使用new创建String b = new String("lowe"); 单独使用””引号创建的字符串都是常量,编译期就已经确定存储到常量池中； 使用new String(“”)创建的对象会存储到堆中,是运行期新创建的； 使用只包含常量的字符串连接符如”aa” + “aa”创建的也是常量,编译期就能确定,已经确定存储到常量池中； 使用包含变量的字符串连接符如”aa” + s1创建的对象是运行期才创建的,存储在堆中； 使用引号创建不一定创建对象 123456String a = "lowe";String b = "lowe";String c = "lo" + we";//a,b,c指向同一个引用，第一次创建后已经在常量池中存在对象了，//第二次创建的时候会去常量池中查找，不会再次创建//在程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，编译后c的值就是“lowe” 使用new创建一定创建对象 123String a = new String("lowe");String b = new String("lowe");//a与b是两个对象 final优化 当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定。1234String a = "lowe";final String b = "lo";String c = b+ "we";//a==c 综合测试123String a = "lowe";String b = "lowe";System.out.println(a==b);//true 123String a=new String("lowe");String b=new String("lowe");System.out.println(a==b);//false 1234//编译期确定String a="lowe";String b="lo"+"we";System.out.println(a==b);//true 1234567//编译期无法确定String a="lowe";String b=new String("lowe");String c="lo" + new String("we");System.out.println(a==b);//falseSystem.out.println(a==c);//falseSystem.out.println(b==c);//false 123456//编译期无法确定String a = "lowe";String b = "lo";String c = "we";String d = b + c;System.out.println(a==d);//false 12345//final优化String a = "lowe";final String b = "lo";String c = b+ "we";System.out.println(a==c);//true 12345678910//虽然用final修饰了，但是是通过方法调用返回的，只能在运行期确定&#123; String a = "lowe"; final String b = getStr(); String c = b+ "we"; System.out.println(a==c);//false&#125;private static String getStr()&#123; return "lo";&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
